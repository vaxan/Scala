object Puzzle {
	/**
	* Tile is an algebraic data type composed of nine other types.
	* Each represent a tile of the puzzle, including the empty one.
	*/
	sealed abstract class Tile
	case object Empty extends Tile
	case object One extends Tile
	case object Two extends Tile
	case object Three extends Tile
	case object Four extends Tile
	case object Five extends Tile
	case object Six extends Tile
	case object Seven extends Tile
	case object Eight extends Tile
	/**
	* Puzzle is a list of tiles.
	*/
	type Puzzle = List[Tile]
	/**
	* Given a Puzzle, return a list of new puzzles, that is, a list of
	* new possible states. These are generated by "moving" tiles according to
	* the restrictions of the puzzle.
	*/
	def unfold (p: Puzzle): List[Puzzle] = {
		/**
		* Swap the position of two elements given their index in the list.
		*/
		def swap(p: Puzzle, i1: Int, i2: Int): Puzzle = {
			require(i1 < i2, "i1 should be an index lower than i2")
			val (a, h1 :: b) = p.splitAt(i1)
			val (c, h2 :: d) = b.splitAt(i2 - i1 - 1)
			a ::: (h2 :: c) ::: (h1 :: d)
		}
		var children: List[Puzzle] = Nil
		val i = p.indexWhere(_ == Empty)
		val row = i / 3
		val col = i - (3 * row)
		if (col < 2) children = swap(p, i, i + 1) :: children	// right
		if (col > 0) children = swap(p, i - 1, i) :: children	// left
		if (row < 2) children = swap(p, i, i + 3) :: children	// bottom
		if (row > 0) children = swap(p, i - 3, i) :: children	// top
		children
	}
	/**
	* Returns true if the given puzzle represents a solution, false otherwise.
	*/
	def isSolution(p: Puzzle): Boolean =
		p.filter(_ != Empty) == List(One, Two, Three, Four, Five, Six, Seven, Eight)
	/**
	* Generates a new random puzzle.
	*/
	def newPuzzle: Puzzle = scala.util.Random.shuffle{
		List(Empty, One, Two, Three, Four, Five, Six, Seven, Eight)
	}
	// ==========================================
import scala.collection.mutable.Map
import scala.collection.mutable.Stack
val goalState:Puzzle = List(One, Two, Three, Four, Five, Six, Seven, Eight)
//Converts the Strings to Int to check if given puzzle is solvable
def solvableInt(a:Puzzle,l:List[Int]):List[Int]={
     val p:Puzzle = a.filter(_ != Empty)
     if(p.isEmpty) l
     else if(p.head == One){
        solvableInt(p.tail, l :+ 1)
     }
     else if(p.head == Two){
        solvableInt(p.tail, l :+ 2)
     }
     else if(p.head == Three){
        solvableInt(p.tail, l :+ 3)
     }
     else if(p.head == Four){
        solvableInt(p.tail, l :+ 4)
     }
     else if(p.head == Five){
        solvableInt(p.tail, l :+ 5)
     }
     else if(p.head == Six){
        solvableInt(p.tail, l :+ 6)
     }
     else if(p.head == Seven){
        solvableInt(p.tail, l :+ 7)
     }
	 else{
	    solvableInt(p.tail, l :+ 8)
 }
}
//Checks the number of inversions in the given list
def solvable(p:List[Int]):Boolean = {
  var inversions:Int = 0
  for(i <- 0 until p.size){
	for(j <- i+1 until p.size){
	   if(p(j) > p(i)){
		 inversions = inversions + 1
		}
	}
  }
  if(inversions%2 == 1){
		return false;
	}else{
		return true;
	}
}
//Depth First Search
//Uses depth first search algorithm
//Uses Lists to store unvisited and visited node
//Visited List stores Puzzle which were already visited but solution not found
//Initially checks if puzzle is solvable or not
def depthFirst(p:Puzzle):Any = {
   var visited = List[Puzzle]()
   var unvisited = List[Puzzle]()
   var moves = List[Puzzle]()
   def depthSearch(p:Puzzle):Any = {
	if(solvable(solvableInt(p,List()))){
	 var head:Puzzle = p
	 moves = head :: moves
	 if(isSolution(head)) { 
	  return("final_state="+head,"moves="+moves) 
	 }
	 else {
	  unvisited = unvisited.drop(1)
	   if(!visited.contains(head)){
		visited = head :: visited
		 for(n <- unfold(head).reverse){
		  if(!visited.contains(n)){
		   unvisited = n :: unvisited
		  }
		 } 
	     depthSearch(unvisited.head)
	   }   
	 }		   
    }
	else {
	  println("Not Solvable odd inversions")
	  return Nil
	}
   }
	depthSearch(p)	
}
//Heuristics Search
//Check the manhattan distance between the input puzzle and goalState
def manhattan(a:Puzzle,g:Puzzle):Int={
	    val b:Puzzle = a.filter(_ != Empty)
       def manhattanDistance(i:Int):Int = {
         val t = b(i)
         val i2 = goalState.indexOf(t)
        Math.abs(i/3 - i2/3) + Math.abs(i%3 - i2%3)
      }
	   def count1(i: Int, total: Int):Int = {
        if (i != b.size){
     		count1(i + 1, manhattanDistance(i) + total)
		}
        else{
		 total
        }
      }
	   count1(0,0)
}
//Uses A* algorithm using heuristic of manhattan function
//Uses stack to store unvisited node and List for visited
//Initially checks if puzzle is solvable or not
//Uses Map function to hold the cost and its neighbour
def heuristic(p:Puzzle):Any={
 var visited = List[Puzzle]()
 var open = Stack[Puzzle]()
 var moves = List[Puzzle]()
 if(solvable(solvableInt(p,List()))){
  open.push(p)
  visited = p :: visited
  while(!open.isEmpty){
   var top = open.pop
   moves = top :: moves
   var i:Int = 0
   if(isSolution(top)) {
     return ("final_state="+top,"moves="+moves)
   }
   var h = Map[Int,Puzzle]()
   for(neighbour <- unfold(top).reverse){
    if(isSolution(neighbour)) { 
     moves = neighbour :: moves
	 return ("final_state="+neighbour,"moves="+moves)
	}
	if(!visited.contains(neighbour)){
	 val cost = manhattan(neighbour,goalState) - 1
	 h += ((cost,neighbour))
	}
	val k = h.toSeq.sortWith(_._1 > _._1)
	for(i <- 0 until k.size){
	 open.push(k(i)._2)
	}	
	 visited = open.top :: visited	
	}
  }
	return Nil
 }
 else {
    println("Not Solvable odd Inversions")
	return Nil
 }
}
}